{"version":3,"file":"550.bundle.js","mappings":";;;;;AAAA;AACA,IAAI,KAA4D,oBAAoB,mBAAO,CAAC,IAAO,GAAG,mBAAO,CAAC,IAAY;AAC1H,IAAI,CACwH;AAC5H,CAAC,qCAAqC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,8DAA8D,sBAAsB,sBAAsB,wBAAwB,wBAAwB;AAC1J;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA,oCAAoC,KAAK;AACzC,2BAA2B,KAAK,IAAI,MAAM;AAC1C,2BAA2B,KAAK,IAAI,kBAAkB;AACtD,2BAA2B,KAAK,IAAI,kCAAkC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,EAAE,SAAS;AACzC;AACA,kBAAkB,IAAI,EAAE,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiD,IAAI;AAC1E;AACA,sBAAsB,QAAQ,EAAE,SAAS,EAAE,SAAS;AACpD;AACA,mBAAmB,iDAAiD,IAAI;AACxE,sBAAsB,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,SAAS;AAC5D;AACA;AACA;AACA;AACA,mBAAmB,iDAAiD,IAAI;AACxE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,SAAS,EAAE,QAAQ,EAAE;AAC3C;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,kCAAkC;AAClC,oCAAoC;AACpC,mCAAmC;AACnC,kCAAkC;AAClC,+BAA+B;AAC/B,8BAA8B;AAC9B,oCAAoC;AACpC,qCAAqC;AACrC,gCAAgC;AAChC,mCAAmC;AACnC;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB,UAAU;AAC3B,iBAAiB,SAAS;AAC1B,kBAAkB;AAClB;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB;AAClB;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB;AAClB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB,UAAU;AAC5B,kBAAkB,UAAU;AAC5B;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,gBAAgB;AAChB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,EAAE,MAAM,EAAE,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kDAAkD,IAAI,YAAY,MAAM,aAAa,OAAO;AAC5F;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,QAAQ;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6GAA6G,QAAQ;AACrH;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kCAAkC,oBAAoB,IAAI;AAC1D;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,4DAA4D;AACrF;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;;AAEA,mDAAmD,aAAa;;AAEhE,CAAC","sources":["webpack://newwebsite/./node_modules/@bbob/react/dist/index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BbobReact = {}, global.React));\n})(this, (function (exports, React) { 'use strict';\n\n    const N = '\\n';\n    const TAB = '\\t';\n    const EQ = '=';\n    const QUOTEMARK = '\"';\n    const SPACE = ' ';\n    const OPEN_BRAKET = '[';\n    const CLOSE_BRAKET = ']';\n    const SLASH = '/';\n    const BACKSLASH = '\\\\';\n\n    const isTagNode = (el)=>typeof el === 'object' && !!el.tag;\n    const isStringNode = (el)=>typeof el === 'string';\n    const keysReduce = (obj, reduce, def)=>Object.keys(obj).reduce(reduce, def);\n    const getNodeLength = (node)=>{\n        if (isTagNode(node)) {\n            return node.content.reduce((count, contentNode)=>count + getNodeLength(contentNode), 0);\n        }\n        if (isStringNode(node)) {\n            return node.length;\n        }\n        return 0;\n    };\n    /**\n     * Appends value to Tag Node\n     * @param {TagNode} node\n     * @param value\n     */ const appendToNode = (node, value)=>{\n        node.content.push(value);\n    };\n    /**\n     * Replaces \" to &qquot;\n     * @param {String} value\n     */ const escapeHTML = (value)=>value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url\n        .replace(/(javascript|data|vbscript):/gi, '$1%3A');\n    /**\n     * Acept name and value and return valid html5 attribute string\n     * @param {String} name\n     * @param {String} value\n     * @return {string}\n     */ const attrValue = (name, value)=>{\n        const type = typeof value;\n        const types = {\n            boolean: ()=>value ? `${name}` : '',\n            number: ()=>`${name}=\"${value}\"`,\n            string: ()=>`${name}=\"${escapeHTML(value)}\"`,\n            object: ()=>`${name}=\"${escapeHTML(JSON.stringify(value))}\"`\n        };\n        return types[type] ? types[type]() : '';\n    };\n    /**\n     * Transforms attrs to html params string\n     * @param values\n     */ const attrsToString = (values)=>{\n        // To avoid some malformed attributes\n        if (values == null) {\n            return '';\n        }\n        return keysReduce(values, (arr, key)=>[\n                ...arr,\n                attrValue(key, values[key])\n            ], [\n            ''\n        ]).join(' ');\n    };\n    /**\n     * Gets value from\n     * @example\n     * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'\n     * @param attrs\n     * @returns {string}\n     */ const getUniqAttr = (attrs)=>keysReduce(attrs, (res, key)=>attrs[key] === key ? attrs[key] : null, null);\n\n    const getTagAttrs = (tag, params)=>{\n        const uniqAattr = getUniqAttr(params);\n        if (uniqAattr) {\n            const tagAttr = attrValue(tag, uniqAattr);\n            const attrs = {\n                ...params\n            };\n            delete attrs[uniqAattr];\n            const attrsStr = attrsToString(attrs);\n            return `${tagAttr}${attrsStr}`;\n        }\n        return `${tag}${attrsToString(params)}`;\n    };\n    class TagNode {\n        attr(name, value) {\n            if (typeof value !== 'undefined') {\n                this.attrs[name] = value;\n            }\n            return this.attrs[name];\n        }\n        append(value) {\n            return appendToNode(this, value);\n        }\n        get length() {\n            return getNodeLength(this);\n        }\n        toTagStart({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n            const tagAttrs = getTagAttrs(this.tag, this.attrs);\n            return `${openTag}${tagAttrs}${closeTag}`;\n        }\n        toTagEnd({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n            return `${openTag}${SLASH}${this.tag}${closeTag}`;\n        }\n        toTagNode() {\n            return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);\n        }\n        toString({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n            const isEmpty = this.content.length === 0;\n            const content = this.content.reduce((r, node)=>r + node.toString({\n                    openTag,\n                    closeTag\n                }), '');\n            const tagStart = this.toTagStart({\n                openTag,\n                closeTag\n            });\n            if (isEmpty) {\n                return tagStart;\n            }\n            return `${tagStart}${content}${this.toTagEnd({\n            openTag,\n            closeTag\n        })}`;\n        }\n        constructor(tag, attrs, content){\n            this.tag = tag;\n            this.attrs = attrs;\n            this.content = Array.isArray(content) ? content : [\n                content\n            ];\n        }\n    }\n    TagNode.create = (tag, attrs = {}, content = [])=>new TagNode(tag, attrs, content);\n    TagNode.isOf = (node, type)=>node.tag === type;\n\n    // type, value, line, row,\n    const TOKEN_TYPE_ID = 'type'; // 0;\n    const TOKEN_VALUE_ID = 'value'; // 1;\n    const TOKEN_COLUMN_ID = 'row'; // 2;\n    const TOKEN_LINE_ID = 'line'; // 3;\n    const TOKEN_TYPE_WORD = 1; // 'word';\n    const TOKEN_TYPE_TAG = 2; // 'tag';\n    const TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\n    const TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\n    const TOKEN_TYPE_SPACE = 5; // 'space';\n    const TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\n    /**\n     * @param {Token} token\n     * @returns {string}\n     */ const getTokenValue = (token)=>{\n        if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\n            return token[TOKEN_VALUE_ID];\n        }\n        return '';\n    };\n    /**\n     * @param {Token}token\n     * @returns {number}\n     */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\n    const getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\n    /**\n     * @param {Token} token\n     * @returns {boolean}\n     */ const isTextToken = (token)=>{\n        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\n        }\n        return false;\n    };\n    /**\n     * @param {Token} token\n     * @returns {boolean}\n     */ const isTagToken = (token)=>{\n        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\n        }\n        return false;\n    };\n    const isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);\n    const isTagStart = (token)=>!isTagEnd(token);\n    const isAttrNameToken = (token)=>{\n        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\n        }\n        return false;\n    };\n    /**\n     * @param {Token} token\n     * @returns {boolean}\n     */ const isAttrValueToken = (token)=>{\n        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\n        }\n        return false;\n    };\n    const getTagName = (token)=>{\n        const value = getTokenValue(token);\n        return isTagEnd(token) ? value.slice(1) : value;\n    };\n    const convertTagToText = (token)=>{\n        let text = OPEN_BRAKET;\n        text += getTokenValue(token);\n        text += CLOSE_BRAKET;\n        return text;\n    };\n    class Token {\n        isEmpty() {\n            // eslint-disable-next-line no-restricted-globals\n            return isNaN(this[TOKEN_TYPE_ID]);\n        }\n        isText() {\n            return isTextToken(this);\n        }\n        isTag() {\n            return isTagToken(this);\n        }\n        isAttrName() {\n            return isAttrNameToken(this);\n        }\n        isAttrValue() {\n            return isAttrValueToken(this);\n        }\n        isStart() {\n            return isTagStart(this);\n        }\n        isEnd() {\n            return isTagEnd(this);\n        }\n        getName() {\n            return getTagName(this);\n        }\n        getValue() {\n            return getTokenValue(this);\n        }\n        getLine() {\n            return getTokenLine(this);\n        }\n        getColumn() {\n            return getTokenColumn(this);\n        }\n        toString() {\n            return convertTagToText(this);\n        }\n        /**\n       * @param {String} type\n       * @param {String} value\n       * @param line\n       * @param row\n       */ constructor(type, value, line, row){\n            this[TOKEN_TYPE_ID] = Number(type);\n            this[TOKEN_VALUE_ID] = String(value);\n            this[TOKEN_LINE_ID] = Number(line);\n            this[TOKEN_COLUMN_ID] = Number(row);\n        }\n    }\n    const TYPE_WORD = TOKEN_TYPE_WORD;\n    const TYPE_TAG = TOKEN_TYPE_TAG;\n    const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\n    const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\n    const TYPE_SPACE = TOKEN_TYPE_SPACE;\n    const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\n\n    function CharGrabber(source, options) {\n        const cursor = {\n            pos: 0,\n            len: source.length\n        };\n        const substrUntilChar = (char)=>{\n            const { pos  } = cursor;\n            const idx = source.indexOf(char, pos);\n            return idx >= 0 ? source.substring(pos, idx) : '';\n        };\n        const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;\n        const hasNext = ()=>cursor.len > cursor.pos;\n        const isLast = ()=>cursor.pos === cursor.len;\n        const skip = (num = 1, silent)=>{\n            cursor.pos += num;\n            if (options && options.onSkip && !silent) {\n                options.onSkip();\n            }\n        };\n        const rest = ()=>source.substring(cursor.pos);\n        const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);\n        const curr = ()=>source[cursor.pos];\n        const prev = ()=>{\n            const prevPos = cursor.pos - 1;\n            return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;\n        };\n        const next = ()=>{\n            const nextPos = cursor.pos + 1;\n            return nextPos <= source.length - 1 ? source[nextPos] : null;\n        };\n        const grabWhile = (cond, silent)=>{\n            let start = 0;\n            if (hasNext()) {\n                start = cursor.pos;\n                while(hasNext() && cond(curr())){\n                    skip(1, silent);\n                }\n            }\n            return source.substring(start, cursor.pos);\n        };\n        /**\n       * @type {skip}\n       */ this.skip = skip;\n        /**\n       * @returns {Boolean}\n       */ this.hasNext = hasNext;\n        /**\n       * @returns {String}\n       */ this.getCurr = curr;\n        /**\n       * @returns {String}\n       */ this.getRest = rest;\n        /**\n       * @returns {String}\n       */ this.getNext = next;\n        /**\n       * @returns {String}\n       */ this.getPrev = prev;\n        /**\n       * @returns {Boolean}\n       */ this.isLast = isLast;\n        /**\n       * @returns {Boolean}\n       */ this.includes = includes;\n        /**\n       * @param {Function} cond\n       * @param {Boolean} silent\n       * @return {String}\n       */ this.grabWhile = grabWhile;\n        /**\n       * @param {Number} num\n       * @return {String}\n       */ this.grabN = grabN;\n        /**\n       * Grabs rest of string until it find a char\n       * @param {String} char\n       * @return {String}\n       */ this.substrUntilChar = substrUntilChar;\n    }\n    /**\n     * Creates a grabber wrapper for source string, that helps to iterate over string char by char\n     * @param {String} source\n     * @param {Object} options\n     * @param {Function} options.onSkip\n     * @return CharGrabber\n     */ const createCharGrabber = (source, options)=>new CharGrabber(source, options);\n    /**\n     * Trims string from start and end by char\n     * @example\n     *  trimChar('*hello*', '*') ==> 'hello'\n     * @param {String} str\n     * @param {String} charToRemove\n     * @returns {String}\n     */ const trimChar = (str, charToRemove)=>{\n        while(str.charAt(0) === charToRemove){\n            // eslint-disable-next-line no-param-reassign\n            str = str.substring(1);\n        }\n        while(str.charAt(str.length - 1) === charToRemove){\n            // eslint-disable-next-line no-param-reassign\n            str = str.substring(0, str.length - 1);\n        }\n        return str;\n    };\n    /**\n     * Unquotes \\\" to \"\n     * @param str\n     * @return {String}\n     */ const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);\n    function NodeList(values = []) {\n        const nodes = values;\n        const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;\n        const flushLast = ()=>nodes.length ? nodes.pop() : false;\n        const push = (value)=>nodes.push(value);\n        const toArray = ()=>nodes;\n        this.push = push;\n        this.toArray = toArray;\n        this.getLast = getLast;\n        this.flushLast = flushLast;\n    }\n    /**\n     *\n     * @param values\n     * @return {NodeList}\n     */ const createList = (values = [])=>new NodeList(values);\n\n    // for cases <!-- -->\n    const EM = '!';\n    /**\n     * Creates a Token entity class\n     * @param {Number} type\n     * @param {String} value\n     * @param {Number} r line number\n     * @param {Number} cl char number in line\n     */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);\n    /**\n     * @typedef {Object} Lexer\n     * @property {Function} tokenize\n     * @property {Function} isTokenNested\n     */ /**\n     * @param {String} buffer\n     * @param {Object} options\n     * @param {Function} options.onToken\n     * @param {String} options.openTag\n     * @param {String} options.closeTag\n     * @param {Boolean} options.enableEscapeTags\n     * @return {Lexer}\n     */ function createLexer(buffer, options = {}) {\n        const STATE_WORD = 0;\n        const STATE_TAG = 1;\n        const STATE_TAG_ATTRS = 2;\n        const TAG_STATE_NAME = 0;\n        const TAG_STATE_ATTR = 1;\n        const TAG_STATE_VALUE = 2;\n        let row = 0;\n        let col = 0;\n        let tokenIndex = -1;\n        let stateMode = STATE_WORD;\n        let tagMode = TAG_STATE_NAME;\n        let contextFreeTag = '';\n        const tokens = new Array(Math.floor(buffer.length));\n        const openTag = options.openTag || OPEN_BRAKET;\n        const closeTag = options.closeTag || CLOSE_BRAKET;\n        const escapeTags = !!options.enableEscapeTags;\n        const contextFreeTags = options.contextFreeTags || [];\n        const onToken = options.onToken || (()=>{});\n        const RESERVED_CHARS = [\n            closeTag,\n            openTag,\n            QUOTEMARK,\n            BACKSLASH,\n            SPACE,\n            TAB,\n            EQ,\n            N,\n            EM\n        ];\n        const NOT_CHAR_TOKENS = [\n            openTag,\n            SPACE,\n            TAB,\n            N\n        ];\n        const WHITESPACES = [\n            SPACE,\n            TAB\n        ];\n        const SPECIAL_CHARS = [\n            EQ,\n            SPACE,\n            TAB\n        ];\n        const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\n        const isNewLine = (char)=>char === N;\n        const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\n        const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\n        const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\n        const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;\n        const isEscapeChar = (char)=>char === BACKSLASH;\n        const onSkip = ()=>{\n            col++;\n        };\n        const unq = (val)=>unquote(trimChar(val, QUOTEMARK));\n        const checkContextFreeMode = (name, isClosingTag)=>{\n            if (contextFreeTag !== '' && isClosingTag) {\n                contextFreeTag = '';\n            }\n            if (contextFreeTag === '' && contextFreeTags.includes(name)) {\n                contextFreeTag = name;\n            }\n        };\n        const chars = createCharGrabber(buffer, {\n            onSkip\n        });\n        /**\n       * Emits newly created token to subscriber\n       * @param {Number} type\n       * @param {String} value\n       */ function emitToken(type, value) {\n            const token = createToken(type, value, row, col);\n            onToken(token);\n            tokenIndex += 1;\n            tokens[tokenIndex] = token;\n        }\n        function nextTagState(tagChars, isSingleValueTag) {\n            if (tagMode === TAG_STATE_ATTR) {\n                const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));\n                const name = tagChars.grabWhile(validAttrName);\n                const isEnd = tagChars.isLast();\n                const isValue = tagChars.getCurr() !== EQ;\n                tagChars.skip();\n                if (isEnd || isValue) {\n                    emitToken(TYPE_ATTR_VALUE, unq(name));\n                } else {\n                    emitToken(TYPE_ATTR_NAME, name);\n                }\n                if (isEnd) {\n                    return TAG_STATE_NAME;\n                }\n                if (isValue) {\n                    return TAG_STATE_ATTR;\n                }\n                return TAG_STATE_VALUE;\n            }\n            if (tagMode === TAG_STATE_VALUE) {\n                let stateSpecial = false;\n                const validAttrValue = (char)=>{\n                    // const isEQ = char === EQ;\n                    const isQM = char === QUOTEMARK;\n                    const prevChar = tagChars.getPrev();\n                    const nextChar = tagChars.getNext();\n                    const isPrevSLASH = prevChar === BACKSLASH;\n                    const isNextEQ = nextChar === EQ;\n                    const isWS = isWhiteSpace(char);\n                    // const isPrevWS = isWhiteSpace(prevChar);\n                    const isNextWS = isWhiteSpace(nextChar);\n                    if (stateSpecial && isSpecialChar(char)) {\n                        return true;\n                    }\n                    if (isQM && !isPrevSLASH) {\n                        stateSpecial = !stateSpecial;\n                        if (!stateSpecial && !(isNextEQ || isNextWS)) {\n                            return false;\n                        }\n                    }\n                    if (!isSingleValueTag) {\n                        return isWS === false;\n                    // return (isEQ || isWS) === false;\n                    }\n                    return true;\n                };\n                const name1 = tagChars.grabWhile(validAttrValue);\n                tagChars.skip();\n                emitToken(TYPE_ATTR_VALUE, unq(name1));\n                if (tagChars.isLast()) {\n                    return TAG_STATE_NAME;\n                }\n                return TAG_STATE_ATTR;\n            }\n            const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());\n            const name2 = tagChars.grabWhile(validName);\n            emitToken(TYPE_TAG, name2);\n            checkContextFreeMode(name2);\n            tagChars.skip();\n            // in cases when we has [url=someval]GET[/url] and we dont need to parse all\n            if (isSingleValueTag) {\n                return TAG_STATE_VALUE;\n            }\n            const hasEQ = tagChars.includes(EQ);\n            return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\n        }\n        function stateTag() {\n            const currChar = chars.getCurr();\n            const nextChar = chars.getNext();\n            chars.skip();\n            // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\n            const substr = chars.substrUntilChar(closeTag);\n            const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\n            if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\n                emitToken(TYPE_WORD, currChar);\n                return STATE_WORD;\n            }\n            // [myTag   ]\n            const isNoAttrsInTag = substr.indexOf(EQ) === -1;\n            // [/myTag]\n            const isClosingTag = substr[0] === SLASH;\n            if (isNoAttrsInTag || isClosingTag) {\n                const name = chars.grabWhile((char)=>char !== closeTag);\n                chars.skip(); // skip closeTag\n                emitToken(TYPE_TAG, name);\n                checkContextFreeMode(name, isClosingTag);\n                return STATE_WORD;\n            }\n            return STATE_TAG_ATTRS;\n        }\n        function stateAttrs() {\n            const silent = true;\n            const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\n            const tagGrabber = createCharGrabber(tagStr, {\n                onSkip\n            });\n            const hasSpace = tagGrabber.includes(SPACE);\n            tagMode = TAG_STATE_NAME;\n            while(tagGrabber.hasNext()){\n                tagMode = nextTagState(tagGrabber, !hasSpace);\n            }\n            chars.skip(); // skip closeTag\n            return STATE_WORD;\n        }\n        function stateWord() {\n            if (isNewLine(chars.getCurr())) {\n                emitToken(TYPE_NEW_LINE, chars.getCurr());\n                chars.skip();\n                col = 0;\n                row++;\n                return STATE_WORD;\n            }\n            if (isWhiteSpace(chars.getCurr())) {\n                const word = chars.grabWhile(isWhiteSpace);\n                emitToken(TYPE_SPACE, word);\n                return STATE_WORD;\n            }\n            if (chars.getCurr() === openTag) {\n                if (contextFreeTag) {\n                    const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;\n                    const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;\n                    const foundTag = chars.grabN(fullTagLen);\n                    const isEndContextFreeMode = foundTag === fullTagName;\n                    if (isEndContextFreeMode) {\n                        return STATE_TAG;\n                    }\n                } else if (chars.includes(closeTag)) {\n                    return STATE_TAG;\n                }\n                emitToken(TYPE_WORD, chars.getCurr());\n                chars.skip();\n                return STATE_WORD;\n            }\n            if (escapeTags) {\n                if (isEscapeChar(chars.getCurr())) {\n                    const currChar = chars.getCurr();\n                    const nextChar = chars.getNext();\n                    chars.skip(); // skip the \\ without emitting anything\n                    if (isEscapableChar(nextChar)) {\n                        chars.skip(); // skip past the [, ] or \\ as well\n                        emitToken(TYPE_WORD, nextChar);\n                        return STATE_WORD;\n                    }\n                    emitToken(TYPE_WORD, currChar);\n                    return STATE_WORD;\n                }\n                const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\n                const word1 = chars.grabWhile(isChar);\n                emitToken(TYPE_WORD, word1);\n                return STATE_WORD;\n            }\n            const word2 = chars.grabWhile(isCharToken);\n            emitToken(TYPE_WORD, word2);\n            return STATE_WORD;\n        }\n        function tokenize() {\n            stateMode = STATE_WORD;\n            while(chars.hasNext()){\n                switch(stateMode){\n                    case STATE_TAG:\n                        stateMode = stateTag();\n                        break;\n                    case STATE_TAG_ATTRS:\n                        stateMode = stateAttrs();\n                        break;\n                    case STATE_WORD:\n                    default:\n                        stateMode = stateWord();\n                        break;\n                }\n            }\n            tokens.length = tokenIndex + 1;\n            return tokens;\n        }\n        function isTokenNested(token) {\n            const value = openTag + SLASH + token.getValue();\n            // potential bottleneck\n            return buffer.indexOf(value) > -1;\n        }\n        return {\n            tokenize,\n            isTokenNested\n        };\n    }\n\n    /**\n     * @public\n     * @param {String} input\n     * @param {Object} opts\n     * @param {Function} opts.createTokenizer\n     * @param {Array<string>} opts.onlyAllowTags\n     * @param {Array<string>} opts.contextFreeTags\n     * @param {Boolean} opts.enableEscapeTags\n     * @param {String} opts.openTag\n     * @param {String} opts.closeTag\n     * @return {Array}\n     */ const parse = (input, opts = {})=>{\n        const options = opts;\n        const openTag = options.openTag || OPEN_BRAKET;\n        const closeTag = options.closeTag || CLOSE_BRAKET;\n        let tokenizer = null;\n        /**\n       * Result AST of nodes\n       * @private\n       * @type {NodeList}\n       */ const nodes = createList();\n        /**\n       * Temp buffer of nodes that's nested to another node\n       * @private\n       * @type {NodeList}\n       */ const nestedNodes = createList();\n        /**\n       * Temp buffer of nodes [tag..]...[/tag]\n       * @private\n       * @type {NodeList}\n       */ const tagNodes = createList();\n        /**\n       * Temp buffer of tag attributes\n       * @private\n       * @type {NodeList}\n       */ const tagNodesAttrName = createList();\n        /**\n       * Cache for nested tags checks\n       */ const nestedTagsMap = new Set();\n        /**\n       *\n       * @param token\n       * @returns {boolean}\n       */ const isTokenNested = (token)=>{\n            const value = token.getValue();\n            if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {\n                nestedTagsMap.add(value);\n                return true;\n            }\n            return nestedTagsMap.has(value);\n        };\n        /**\n       * @param tagName\n       * @returns {boolean}\n       */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));\n        /**\n       * @private\n       * @param {String} value\n       * @return {boolean}\n       */ const isAllowedTag = (value)=>{\n            if (options.onlyAllowTags && options.onlyAllowTags.length) {\n                return options.onlyAllowTags.indexOf(value) >= 0;\n            }\n            return true;\n        };\n        /**\n       * Flushes temp tag nodes and its attributes buffers\n       * @private\n       * @return {Array}\n       */ const flushTagNodes = ()=>{\n            if (tagNodes.flushLast()) {\n                tagNodesAttrName.flushLast();\n            }\n        };\n        /**\n       * @private\n       * @return {Array}\n       */ const getNodes = ()=>{\n            const lastNestedNode = nestedNodes.getLast();\n            if (lastNestedNode && Array.isArray(lastNestedNode.content)) {\n                return lastNestedNode.content;\n            }\n            return nodes.toArray();\n        };\n        /**\n       * @private\n       * @param {string|TagNode} node\n       */ const appendNodes = (node)=>{\n            const items = getNodes();\n            if (Array.isArray(items)) {\n                if (isTagNode(node)) {\n                    if (isAllowedTag(node.tag)) {\n                        items.push(node.toTagNode());\n                    } else {\n                        items.push(node.toTagStart({\n                            openTag,\n                            closeTag\n                        }));\n                        if (node.content.length) {\n                            node.content.forEach((item)=>{\n                                items.push(item);\n                            });\n                            items.push(node.toTagEnd({\n                                openTag,\n                                closeTag\n                            }));\n                        }\n                    }\n                } else {\n                    items.push(node);\n                }\n            }\n        };\n        /**\n       * @private\n       * @param {Token} token\n       */ const handleTagStart = (token)=>{\n            flushTagNodes();\n            const tagNode = TagNode.create(token.getValue());\n            const isNested = isTokenNested(token);\n            tagNodes.push(tagNode);\n            if (isNested) {\n                nestedNodes.push(tagNode);\n            } else {\n                appendNodes(tagNode);\n            }\n        };\n        /**\n       * @private\n       * @param {Token} token\n       */ const handleTagEnd = (token)=>{\n            flushTagNodes();\n            const lastNestedNode = nestedNodes.flushLast();\n            if (lastNestedNode) {\n                appendNodes(lastNestedNode);\n            } else if (typeof options.onError === 'function') {\n                const tag = token.getValue();\n                const line = token.getLine();\n                const column = token.getColumn();\n                options.onError({\n                    message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,\n                    tagName: tag,\n                    lineNumber: line,\n                    columnNumber: column\n                });\n            }\n        };\n        /**\n       * @private\n       * @param {Token} token\n       */ const handleTag = (token)=>{\n            // [tag]\n            if (token.isStart()) {\n                handleTagStart(token);\n            }\n            // [/tag]\n            if (token.isEnd()) {\n                handleTagEnd(token);\n            }\n        };\n        /**\n       * @private\n       * @param {Token} token\n       */ const handleNode = (token)=>{\n            /**\n         * @type {TagNode}\n         */ const lastTagNode = tagNodes.getLast();\n            const tokenValue = token.getValue();\n            const isNested = isTagNested(token);\n            if (lastTagNode) {\n                if (token.isAttrName()) {\n                    tagNodesAttrName.push(tokenValue);\n                    lastTagNode.attr(tagNodesAttrName.getLast(), '');\n                } else if (token.isAttrValue()) {\n                    const attrName = tagNodesAttrName.getLast();\n                    if (attrName) {\n                        lastTagNode.attr(attrName, tokenValue);\n                        tagNodesAttrName.flushLast();\n                    } else {\n                        lastTagNode.attr(tokenValue, tokenValue);\n                    }\n                } else if (token.isText()) {\n                    if (isNested) {\n                        lastTagNode.append(tokenValue);\n                    } else {\n                        appendNodes(tokenValue);\n                    }\n                } else if (token.isTag()) {\n                    // if tag is not allowed, just past it as is\n                    appendNodes(token.toString());\n                }\n            } else if (token.isText()) {\n                appendNodes(tokenValue);\n            } else if (token.isTag()) {\n                // if tag is not allowed, just past it as is\n                appendNodes(token.toString());\n            }\n        };\n        /**\n       * @private\n       * @param {Token} token\n       */ const onToken = (token)=>{\n            if (token.isTag()) {\n                handleTag(token);\n            } else {\n                handleNode(token);\n            }\n        };\n        tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {\n            onToken,\n            openTag,\n            closeTag,\n            onlyAllowTags: options.onlyAllowTags,\n            contextFreeTags: options.contextFreeTags,\n            enableEscapeTags: options.enableEscapeTags\n        });\n        // eslint-disable-next-line no-unused-vars\n        tokenizer.tokenize();\n        return nodes.toArray();\n    };\n\n    /* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object';\n    const isBool = (value)=>typeof value === 'boolean';\n    function iterate(t, cb) {\n        const tree = t;\n        if (Array.isArray(tree)) {\n            for(let idx = 0; idx < tree.length; idx++){\n                tree[idx] = iterate(cb(tree[idx]), cb);\n            }\n        } else if (tree && isObj(tree) && tree.content) {\n            iterate(tree.content, cb);\n        }\n        return tree;\n    }\n    function same(expected, actual) {\n        if (typeof expected !== typeof actual) {\n            return false;\n        }\n        if (!isObj(expected) || expected === null) {\n            return expected === actual;\n        }\n        if (Array.isArray(expected)) {\n            return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));\n        }\n        return Object.keys(expected).every((key)=>{\n            const ao = actual[key];\n            const eo = expected[key];\n            if (isObj(eo) && eo !== null && ao !== null) {\n                return same(eo, ao);\n            }\n            if (isBool(eo)) {\n                return eo !== (ao === null);\n            }\n            return ao === eo;\n        });\n    }\n    function match(expression, cb) {\n        return Array.isArray(expression) ? iterate(this, (node)=>{\n            for(let idx = 0; idx < expression.length; idx++){\n                if (same(expression[idx], node)) {\n                    return cb(node);\n                }\n            }\n            return node;\n        }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);\n    }\n\n    function walk(cb) {\n        return iterate(this, cb);\n    }\n    function bbob(plugs) {\n        const plugins = typeof plugs === 'function' ? [\n            plugs\n        ] : plugs || [];\n        let options = {\n            skipParse: false\n        };\n        return {\n            process (input, opts) {\n                options = opts || {};\n                const parseFn = options.parser || parse;\n                const renderFn = options.render;\n                const data = options.data || null;\n                if (typeof parseFn !== 'function') {\n                    throw new Error('\"parser\" is not a function, please pass to \"process(input, { parser })\" right function');\n                }\n                let tree = options.skipParse ? input || [] : parseFn(input, options);\n                // raw tree before modification with plugins\n                const raw = tree;\n                tree.messages = [];\n                tree.options = options;\n                tree.walk = walk;\n                tree.match = match;\n                plugins.forEach((plugin)=>{\n                    tree = plugin(tree, {\n                        parse: parseFn,\n                        render: renderFn,\n                        iterate,\n                        match,\n                        data\n                    }) || tree;\n                });\n                return {\n                    get html () {\n                        if (typeof renderFn !== 'function') {\n                            throw new Error('\"render\" function not defined, please pass to \"process(input, { render })\"');\n                        }\n                        return renderFn(tree, tree.options);\n                    },\n                    tree,\n                    raw,\n                    messages: tree.messages\n                };\n            }\n        };\n    }\n\n    const SELFCLOSE_END_TAG = '/>';\n    const CLOSE_START_TAG = '</';\n    const START_TAG = '<';\n    const END_TAG = '>';\n    const renderNode = (node, { stripTags =false  })=>{\n        if (!node) return '';\n        const type = typeof node;\n        if (type === 'string' || type === 'number') {\n            return node;\n        }\n        if (type === 'object') {\n            if (stripTags === true) {\n                // eslint-disable-next-line no-use-before-define\n                return renderNodes(node.content, {\n                    stripTags\n                });\n            }\n            if (node.content === null) {\n                return [\n                    START_TAG,\n                    node.tag,\n                    attrsToString(node.attrs),\n                    SELFCLOSE_END_TAG\n                ].join('');\n            }\n            // eslint-disable-next-line no-use-before-define\n            return [\n                START_TAG,\n                node.tag,\n                attrsToString(node.attrs),\n                END_TAG,\n                renderNodes(node.content),\n                CLOSE_START_TAG,\n                node.tag,\n                END_TAG\n            ].join('');\n        }\n        if (Array.isArray(node)) {\n            // eslint-disable-next-line no-use-before-define\n            return renderNodes(node, {\n                stripTags\n            });\n        }\n        return '';\n    };\n    const renderNodes = (nodes, { stripTags =false  } = {})=>[].concat(nodes).reduce((r, node)=>r + renderNode(node, {\n                stripTags\n            }), '');\n    const render$1 = renderNodes;\n\n    const toAST = (source, plugins, options)=>bbob(plugins).process(source, {\n            ...options,\n            render: (input)=>render$1(input, {\n                    stripTags: true\n                })\n        }).tree;\n    const isContentEmpty = (content)=>!content || content.length === 0;\n    function tagToReactElement(node, index) {\n        return /*#__PURE__*/ React.createElement(node.tag, {\n            ...node.attrs,\n            key: index\n        }, isContentEmpty(node.content) ? null : renderToReactNodes(node.content));\n    }\n    function renderToReactNodes(nodes) {\n        const els = [].concat(nodes).reduce((arr, node, index)=>{\n            if (isTagNode(node)) {\n                arr.push(tagToReactElement(node, index));\n            } else if (isStringNode(node)) {\n                arr.push(node);\n            }\n            return arr;\n        }, []);\n        return els;\n    }\n    function render(source, plugins, options) {\n        return renderToReactNodes(toAST(source, plugins, options));\n    }\n\n    const content = (children, plugins, options)=>React.Children.map(children, (child)=>typeof child === 'string' ? render(child, plugins, options) : child);\n    const Component = ({ container , componentProps , children , plugins , options  })=>/*#__PURE__*/ React.createElement(container, componentProps, content(children, plugins, options));\n    Component.defaultProps = {\n        container: 'span',\n        plugins: [],\n        options: {},\n        componentProps: {}\n    };\n\n    exports.default = Component;\n    exports.render = render;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"names":[],"sourceRoot":""}