{"version":3,"file":"488.bundle.js","mappings":"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CnC,IAAI,CAAC0B,EAAE,CAAC;EAC7D;EACA,OAAO,IAAIU,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;IACtCd,oBAAI,CACDe,IAAI,CAAE,GAAE/C,oBAAM,CAACW,cAAe,YAAWuB,EAAG,WAAU,EAAEI,QAAQ,CAAC,CACjEU,IAAI,CAAC,UAACxC,IAAI;MAAA,OAAKqC,OAAO,CAACrC,IAAI,CAAC;IAAA,EAAC,CAC7ByC,KAAK,CAACH,MAAM,CAAC;EAClB,CAAC,CAAC;AACJ,CAAC;AAED,yDAAeb,UAAU;;ACxBzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI,kBAAkB,IAAI,MAAM;AAC5E;AACA;AACA,aAAa;AACb,YAAY;AACZ,YAAY;AACZ,cAAc;AACd,aAAa;AACb;AACA;AACA,SAAS,iBAAM;AACf;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6DAA6D;;AAE7D;AACA,WAAW,QAAQ;AACnB;AACA,SAAS,mBAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAQ;AACxC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,0BAA0B;AAC1B,6DAA6D;;AAE7D;AACA;AACA,IAAI;AACJ;AACA;;AAEA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,iBAAM;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iBAAM;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,IAAI,IAAI,eAAe,SAAS,KAAK;;AAEnE;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI,EAAE,KAAK;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,0CAA0C;AAC1C,4CAA4C;AAC5C;AACA;AACA;;AAEA;;AAEA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,IAAI,yBAAyB,aAAa,IAAI;AAC/F,yCAAyC,IAAI,yBAAyB,SAAS,GAAG,SAAS,GAAG,WAAW,GAAG;AAC5G,kDAAkD,IAAI,yBAAyB;AAC/E,mDAAmD,IAAI,yBAAyB;;AAEhF;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,IAAI,MAAM,EAAE;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yEAAyE;AACzE;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAM;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS,YAAY;AACnE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,iFAAiF,SAAS,YAAY;AACtG;;AAEA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAM;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,EAAE,GAAG,GAAG;AACxD,wCAAwC,EAAE,GAAG,EAAE;;AAE/C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B;;AAE/B;;AAEA,oCAAoC;AACpC;AACA;AACA,UAAU,iCAAiC;AAC3C;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;;AAEA,sCAAsC;;AAEtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAM;AACrB;AACA,QAAQ;AACR,eAAe,iBAAM;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAM;AACrB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,eAAe,iBAAM;AACrB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iBAAM;AACxG,QAAQ;AACR,eAAe,iBAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,cAAc,IAAI,GAAG,GAAG,sBAAsB,GAAG,6CAA6C,IAAI;AAClG,UAAU,IAAI,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG;AAC/D,eAAe,IAAI,GAAG,IAAI;AAC1B,mBAAmB,IAAI;AACvB,aAAa,IAAI;AACjB,YAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,IAAI;AAChC;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,GAAG,SAAS,GAAG,WAAW,GAAG;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,IAAI,EAAE,KAAK;AACpC;AACA;AACA,4BAA4B,IAAI;AAChC,wBAAwB,IAAI,KAAK,GAAG,kBAAkB,GAAG;AACzD,sBAAsB,IAAI;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;;AAEA;AACA;AACA,yBAAyB,IAAI,EAAE,KAAK;AACpC,4BAA4B,IAAI;AAChC,sBAAsB,EAAE;AACxB,wBAAwB,IAAI,KAAK,GAAG,kBAAkB,GAAG;AACzD,sBAAsB,IAAI;AAC1B;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,IAAI,EAAE,KAAK;AACpC;AACA;AACA,4BAA4B,IAAI;AAChC,wBAAwB,IAAI,KAAK,GAAG,kBAAkB,GAAG;AACzD,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,GAAG;AAC1C,gEAAgE,GAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA,6BAA6B,KAAK;AAClC;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,eAAe,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,GAAG;AACd;AACA,2BAA2B,GAAG,8CAA8C,GAAG;AAC/E;AACA;;AAEA;AACA;AACA,0CAA0C,cAAc,EAAE;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,eAAe,EAAE;;AAE1D,yCAAyC,KAAK;AAC9C,2CAA2C,EAAE,kCAAkC,KAAK,6CAA6C,KAAK;AACtI;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC,UAAU;AAC1E;AACA,+BAA+B,GAAG,iCAAiC,GAAG,6EAA6E,GAAG,+BAA+B,GAAG,gCAAgC,GAAG;AAC3N;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,GAAG;AACnC;AACA,6BAA6B,GAAG;AAChC,gBAAgB,IAAI;AACpB;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD,iEAAiE;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,aAAa;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD,iEAAiE;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4BAA4B,iBAAM;AAClC;AACA;;AAEA;AACA;AACA,QAAQ,iBAAM;AACd;AACA,0BAA0B,iBAAM;AAChC;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,4BAA4B,MAAM;AAClC;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA,kBAAkB,OAAO,MAAM,GAAG,IAAI,KAAK,KAAK,MAAM;AACtD;;AAEA;AACA,gBAAgB,MAAM,GAAG,KAAK,KAAK,MAAM;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB,KAAK;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB,KAAK;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,+BAA+B,KAAK;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;AACA;AACA,YAAY,MAAM,SAAS,YAAY;AACvC,YAAY,KAAK;AACjB,gCAAgC,KAAK;AACrC;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB,KAAK;AACvB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB,KAAK;AACzB;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,mBAAmB,KAAK;AACxB;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,KAAK,SAAS,KAAK;AAC9C;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,EAAE;AAC1E;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,QAAQ;AAC9B;;AAEA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU,iBAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,aAAa;;AAElE;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0IAA0I;AAC1I;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sDAAM;AACpB;AACA;;AAEoL;;;ACt0FpI;AACjB;;AAE/B;AACA,UAAU;AACV,SAAS;AACT,SAAS;AACT,WAAW;AACX,UAAU;AACV;AACA;AACA,sDAAsD;AACtD;AACA,MAAM,qBAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,yCAAyC;AACjI,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW,wBAAwB;AACnF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW,wBAAwB;AACnF;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,MAAM;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,mBAAmB;AACxI;AACA;AACA;AACA,uHAAuH,sBAAsB;AAC7I;AACA;AACA,oCAAoC,qEAAqE,EAAE,KAAK;AAChH,wHAAwH,WAAW;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAyH,2CAA2C;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAyH,oBAAoB;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mMAAmM;AACnM;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA,WAAW,uBAAa,mCAAmC;AAC3D,CAAC;AACD;AACA;;AAEA;AACA;AACA,2FAA2F,mBAAmB;AAC9G;AACA;AACA,8FAA8F,sBAAsB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW,uBAAa,CAAC,cAAQ;AACjC;;AAE2D;;;ACzUnB;AACf;AACmB;AACqB;AAC1B;AACM;AACV;AACC;AA2BnB,SAASoB,eAAeA,CAAAC,IAAA,EAAuF;EAAA,IAAtF;IAACpB,EAAE;IAACE,OAAO;IAACmB,IAAI;IAAEC;EAAiE,CAAC,GAAAF,IAAA;EAC5H,MAAM,CAACG,OAAO,EAAEC,UAAU,CAAC,GAAG9D,kBAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACuC,OAAO,EAAEwB,UAAU,CAAC,GAAG/D,kBAAQ,CAAS,EAAE,CAAC;EAClD,MAAM;IAACY,IAAI;IAAEC,KAAK;IAAEC,SAAS;IAAEkD;EAAO,CAAC,GAAG9D,6BAAM,CAC7C,0DAAyDoC,EAAG,kBAAiBqB,IAAK,aAAY,EAC/F1D,oBACF,CAAC;EACD,IAAI,CAACW,IAAI,IAAKC,KAAK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","sources":["webpack://newwebsite/./src/components/Account/NavBarAccount.tsx","webpack://newwebsite/./src/api/account/tickets/addMessage.ts","webpack://newwebsite/./node_modules/marked/lib/marked.esm.js","webpack://newwebsite/./node_modules/marked-react/dist/marked-react.js","webpack://newwebsite/./src/components/Account/Ticket/ConversationRow.tsx","webpack://newwebsite/./src/api/account/tickets/updateTicket.ts","webpack://newwebsite/./src/components/Account/Ticket/TicketViewContainer.tsx"],"sourcesContent":["import { Link, useLocation, useNavigate } from \"react-router-dom\";\nimport React, { useEffect, useState } from \"react\";\nimport { Account } from \"./Manager/AccountContainer\";\nimport Spinner from \"../Elements/Spinner\";\nimport { fetcher } from \"../../api/http\";\nimport useSWR from \"swr\";\nimport Loading from \"../Elements/Loading\";\nimport { config } from \"../../config/config\";\n\ninterface tabs {\n    tab: string;\n}\nexport default function NavBarAccount(tab: tabs) {\n  const location = useLocation();\n  const [admin, showAdmin] = useState<boolean>(location.pathname.startsWith('/admin/'));\n\n  const { data, error, isLoading } = useSWR(\n    `${config.privateapilink}/auth/isLogged?infos=true`,\n    fetcher\n  );\n      if (!data || (error || isLoading)) {\n        return <Loading/>;\n      }\n\n  \n    return (\n      <>      <h1 className='text-4xl my-4 text-center'>Hello, {!data || (error || isLoading) ? 'User' : data.data.name[0].toUpperCase() + data.data.name.slice(1, data.data.name.length)}</h1>\n        <section className='mx-auto text-center'>\n        <ul className=\"menu menu-horizontal rounded-box gap-x-2\" >\n            {!admin ? (\n                <>\n          <li>\n            <Link className={tab.tab === 'manage' ? 'bg-neutral-focus disabled' : ''} to={'/account/manage'} >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6\" /></svg>\n              Manage Account\n            </Link>\n          </li>\n          <li>\n            <Link className={tab.tab === 'licenses' ? 'bg-neutral-focus disabled' : ''} to={'/account/licenses'}>\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" /></svg>\n              Licenses\n            </Link>\n          </li>\n          <li>\n            <Link to={'/account/orders'} className={tab.tab === 'orders' ? 'bg-neutral-focus disabled' : ''}>\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" /></svg>\n              Orders\n            </Link>\n          </li>\n          <li>\n          <Link className={tab.tab === 'tickets' ? 'bg-neutral-focus disabled' : ''} to={'/account/tickets'} >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\" className=\"w-5 h-5\">\n  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z\" />\n</svg>\n  Tickets\n                </Link>\n                </li>\n          </>\n            ) : (\n            <>\n            <li>\n                <Link className={tab.tab === 'users' ? 'bg-neutral-focus disabled' : ''} to={'/admin/users'} >\n                <svg className=\"w-5 h-5\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z\" /></svg>\nUsers\n                </Link>\n            </li>\n            <li>\n                <Link className={tab.tab === 'products' ? 'bg-neutral-focus disabled' : ''} to={'/admin/products'} >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\" className=\"w-5 h-5\">\n  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M2.25 3h1.386c.51 0 .955.343 1.087.835l.383 1.437M7.5 14.25a3 3 0 00-3 3h15.75m-12.75-3h11.218c1.121-2.3 2.1-4.684 2.924-7.138a60.114 60.114 0 00-16.536-1.84M7.5 14.25L5.106 5.272M6 20.25a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm12.75 0a.75.75 0 11-1.5 0 .75.75 0 011.5 0z\" />\n</svg>\nProducts\n                </Link>\n            </li>\n            <li>\n                <Link className={tab.tab === 'invoices' ? 'bg-neutral-focus disabled' : ''} to={'/admin/invoices'} >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\" className=\"w-5 h-5\">\n  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10\" />\n</svg>\n     Invoices\n                </Link>\n            </li>\n\n              <li>\n                <Link className={tab.tab === 'blogs' ? 'bg-neutral-focus disabled' : ''} to={'/admin/blogs'} >\n                  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" className=\"w-5 h-5\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                    <path d=\"M4 2h16c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2zm5 3h6M7 10h10M7 14h10M7 18h7\" />\n                  </svg>\n                  Blog\n                </Link>\n              </li>\n            </>\n\n            )}\n            {data.data.role ?\n            <>\n                <input type=\"checkbox\" className=\"toggle toggle-success ml-8 my-auto\" checked={admin} onClick={() => showAdmin(!admin)} /> <p className=\"mx-2 my-auto\">Show admin</p></>\n                :\n                <></>\n            } \n        </ul>\n        {admin &&\n    <h1 className='text-center text-red-500 text-xl font-semibold'>ADMINISTRATOR MODE</h1>    \n  \n    }\n      </section>\n\n        </>\n    )\n}\n","import { config } from \"../../../config/config\";\nimport http from \"../../http\";\nimport { Account } from \"../../../components/Account/Manager/Forms/EditAccountForm\";\n\n\nconst addMessage = (id: string, message: string, account: Account, attachments?: File[]): Promise<any> => {\n  const formData = new FormData();\n  formData.append('message', message);\n  if (attachments) {\n    attachments.forEach((file) => {\n      formData.append('attachments[]', file);\n    });\n  }\n  if(account.discord) {\n    formData.append('discord_user_id', account.discord.data.id);\n  }\n  return new Promise((resolve, reject) => {\n    http\n      .post(`${config.privateapilink}/tickets/${id}/messages`, formData)\n      .then((data) => resolve(data))\n      .catch(reject);\n  });\n};\n\nexport default addMessage;","/**\n * marked v4.3.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\nfunction getDefaults() {\n  return {\n    async: false,\n    baseUrl: null,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    hooks: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartypants: false,\n    tokenizer: null,\n    walkTokens: null,\n    xhtml: false\n  };\n}\n\nlet defaults = getDefaults();\n\nfunction changeDefaults(newDefaults) {\n  defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n/**\n * @param {string} html\n */\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\n\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */\nfunction edit(regex, opt) {\n  regex = typeof regex === 'string' ? regex : regex.source;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n/**\n * @param {string} base\n * @param {string} href\n */\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) { cells.shift(); }\n  if (cells.length > 0 && !cells[cells.length - 1].trim()) { cells.pop(); }\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\n// copied from https://stackoverflow.com/a/5450113/806777\n/**\n * @param {string} pattern\n * @param {number} count\n */\nfunction repeatString(pattern, count) {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1;\n    pattern += pattern;\n  }\n  return result + pattern;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n  const href = link.href;\n  const title = link.title ? escape(link.title) : null;\n  const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    lexer.state.inLink = true;\n    const token = {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text,\n      tokens: lexer.inlineTokens(text)\n    };\n    lexer.state.inLink = false;\n    return token;\n  }\n  return {\n    type: 'image',\n    raw,\n    href,\n    title,\n    text: escape(text)\n  };\n}\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nclass Tokenizer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  space(src) {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0]\n      };\n    }\n  }\n\n  code(src) {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ {1,4}/gm, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text\n      };\n    }\n  }\n\n  fences(src) {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],\n        text\n      };\n    }\n  }\n\n  heading(src) {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (/#$/.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || / $/.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text)\n      };\n    }\n  }\n\n  hr(src) {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: cap[0]\n      };\n    }\n  }\n\n  blockquote(src) {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ *>[ \\t]?/gm, '');\n      const top = this.lexer.state.top;\n      this.lexer.state.top = true;\n      const tokens = this.lexer.blockTokens(text);\n      this.lexer.state.top = top;\n      return {\n        type: 'blockquote',\n        raw: cap[0],\n        tokens,\n        text\n      };\n    }\n  }\n\n  list(src) {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,\n        line, nextLine, rawLine, itemContents, endEarly;\n\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: []\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        endEarly = false;\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n        nextLine = src.split('\\n', 1)[0];\n\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimLeft();\n        } else {\n          indent = cap[2].search(/[^ ]/); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        blankLine = false;\n\n        if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            rawLine = src.split('\\n', 1)[0];\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(src)) {\n              break;\n            }\n\n            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLine.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.search(/[^ ]/) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLine.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (/\\n *\\n *$/.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = /^\\[[ xX]\\] /.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      list.items[list.items.length - 1].raw = raw.trimRight();\n      list.items[list.items.length - 1].text = itemContents.trimRight();\n      list.raw = list.raw.trimRight();\n\n      const l = list.items.length;\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (i = 0; i < l; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (i = 0; i < l; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src) {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token = {\n        type: 'html',\n        raw: cap[0],\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      };\n      if (this.options.sanitize) {\n        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n        token.type = 'paragraph';\n        token.text = text;\n        token.tokens = this.lexer.inline(text);\n      }\n      return token;\n    }\n  }\n\n  def(src) {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title\n      };\n    }\n  }\n\n  table(src) {\n    const cap = this.rules.block.table.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1]).map(c => { return { text: c }; }),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        item.raw = cap[0];\n\n        let l = item.align.length;\n        let i, j, k, row;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.rows.length;\n        for (i = 0; i < l; i++) {\n          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => { return { text: c }; });\n        }\n\n        // parse child tokens inside headers and cells\n\n        // header child tokens\n        l = item.header.length;\n        for (j = 0; j < l; j++) {\n          item.header[j].tokens = this.lexer.inline(item.header[j].text);\n        }\n\n        // cell child tokens\n        l = item.rows.length;\n        for (j = 0; j < l; j++) {\n          row = item.rows[j];\n          for (k = 0; k < row.length; k++) {\n            row[k].tokens = this.lexer.inline(row[k].text);\n          }\n        }\n\n        return item;\n      }\n    }\n  }\n\n  lheading(src) {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1])\n      };\n    }\n  }\n\n  paragraph(src) {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text)\n      };\n    }\n  }\n\n  text(src) {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0])\n      };\n    }\n  }\n\n  escape(src) {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: escape(cap[1])\n      };\n    }\n  }\n\n  tag(src) {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: this.options.sanitize\n          ? 'text'\n          : 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        text: this.options.sanitize\n          ? (this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0]))\n          : cap[0]\n      };\n    }\n  }\n\n  link(src) {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(/>$/.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (/^</.test(href)) {\n        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n        title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n      }, cap[0], this.lexer);\n    }\n  }\n\n  reflink(src, links) {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n        || (cap = this.rules.inline.nolink.exec(src))) {\n      let link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = links[link.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer);\n    }\n  }\n\n  emStrong(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.emStrong.lDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n      const lLength = match[0].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = rDelim.length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n\n        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text)\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text)\n        };\n      }\n    }\n  }\n\n  codespan(src) {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(/\\n/g, ' ');\n      const hasNonSpaceChars = /[^ ]/.test(text);\n      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      text = escape(text, true);\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  br(src) {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0]\n      };\n    }\n  }\n\n  del(src) {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2])\n      };\n    }\n  }\n\n  autolink(src, mangle) {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  url(src, mangle) {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  inlineText(src, smartypants) {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      let text;\n      if (this.lexer.state.inRawBlock) {\n        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];\n      } else {\n        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n      }\n      return {\n        type: 'text',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n}\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^(?: *(?:\\n|$))+/,\n  code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n  fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n  hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n  table: noopTest,\n  lheading: /^((?:.|\\n(?!\\n))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */)\n  .replace('bull', block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = { ...block };\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = {\n  ...block.normal,\n  table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n};\n\nblock.gfm.table = edit(block.gfm.table)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.gfm.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('table', block.gfm.table) // interrupt paragraphs with table\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = {\n  ...block.normal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n};\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n  nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n  reflinkSearch: 'reflink|nolink(?!\\\\()',\n  emStrong: {\n    lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n    rDelimAst: /^(?:[^_*\\\\]|\\\\.)*?\\_\\_(?:[^_*\\\\]|\\\\.)*?\\*(?:[^_*\\\\]|\\\\.)*?(?=\\_\\_)|(?:[^*\\\\]|\\\\.)+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[^punct*_\\s])/,\n    rDelimUnd: /^(?:[^_*\\\\]|\\\\.)*?\\*\\*(?:[^_*\\\\]|\\\\.)*?\\_(?:[^_*\\\\]|\\\\.)*?(?=\\*\\*)|(?:[^_\\\\]|\\\\.)+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n  },\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n  punctuation: /^([\\spunctuation])/\n};\n\n// list of punctuation marks from CommonMark spec\n// without * and _ to handle the different emphasis markers * and _\ninline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n// lookbehind is not available on Safari as of version 16\n// inline.escapedEmSt = /(?<=(?:^|[^\\\\)(?:\\\\[^])*)\\\\[*_]/g;\ninline.escapedEmSt = /(?:^|[^\\\\])(?:\\\\\\\\)*\\\\[*_]/g;\n\ninline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim)\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', inline._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.nolink = edit(inline.nolink)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.reflinkSearch = edit(inline.reflinkSearch, 'g')\n  .replace('reflink', inline.reflink)\n  .replace('nolink', inline.nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = { ...inline };\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = {\n  ...inline.normal,\n  strong: {\n    start: /^__|\\*\\*/,\n    middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    endAst: /\\*\\*(?!\\*)/g,\n    endUnd: /__(?!_)/g\n  },\n  em: {\n    start: /^_|\\*/,\n    middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n    endAst: /\\*(?!\\*)/g,\n    endUnd: /_(?!_)/g\n  },\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n};\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = {\n  ...inline.normal,\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = {\n  ...inline.gfm,\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n};\n\n/**\n * smartypants text replacement\n * @param {string} text\n */\nfunction smartypants(text) {\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n}\n\n/**\n * mangle email addresses\n * @param {string} text\n */\nfunction mangle(text) {\n  let out = '',\n    i,\n    ch;\n\n  const l = text.length;\n  for (i = 0; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n}\n\n/**\n * Block Lexer\n */\nclass Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true\n    };\n\n    const rules = {\n      block: block.normal,\n      inline: inline.normal\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    let next;\n    while (next = this.inlineQueue.shift()) {\n      this.inlineTokens(next.src, next.tokens);\n    }\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src, tokens = []) {\n    if (this.options.pedantic) {\n      src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n    } else {\n      src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n        return leading + '    '.repeat(tabs.length);\n      });\n    }\n\n    let token, lastToken, cutSrc, lastParagraphClipped;\n\n    while (src) {\n      if (this.options.extensions\n        && this.options.extensions.block\n        && this.options.extensions.block.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.length === 1 && tokens.length > 0) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unecessary paragraph tags\n          tokens[tokens.length - 1].raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        lastToken = tokens[tokens.length - 1];\n        if (lastParagraphClipped && lastToken.type === 'paragraph') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = (cutSrc.length !== src.length);\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src, tokens = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src, tokens = []) {\n    let token, lastToken, cutSrc;\n\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match;\n    let keepPrevChar, prevChar;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out escaped em & strong delimiters\n    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;\n    }\n\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      // extensions\n      if (this.options.extensions\n        && this.options.extensions.inline\n        && this.options.extensions.inline.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src, mangle)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n\n/**\n * Renderer\n */\nclass Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    code = code.replace(/\\n$/, '') + '\\n';\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  /**\n   * @param {string} quote\n   */\n  blockquote(quote) {\n    return `<blockquote>\\n${quote}</blockquote>\\n`;\n  }\n\n  html(html) {\n    return html;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      const id = this.options.headerPrefix + slugger.slug(raw);\n      return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n    }\n\n    // ignore IDs\n    return `<h${level}>${text}</h${level}>\\n`;\n  }\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  /**\n   * @param {string} text\n   */\n  listitem(text) {\n    return `<li>${text}</li>\\n`;\n  }\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  }\n\n  /**\n   * @param {string} text\n   */\n  paragraph(text) {\n    return `<p>${text}</p>\\n`;\n  }\n\n  /**\n   * @param {string} header\n   * @param {string} body\n   */\n  table(header, body) {\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  /**\n   * @param {string} content\n   */\n  tablerow(content) {\n    return `<tr>\\n${content}</tr>\\n`;\n  }\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? `<${type} align=\"${flags.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n`;\n  }\n\n  /**\n   * span level renderer\n   * @param {string} text\n   */\n  strong(text) {\n    return `<strong>${text}</strong>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  em(text) {\n    return `<em>${text}</em>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  codespan(text) {\n    return `<code>${text}</code>`;\n  }\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  /**\n   * @param {string} text\n   */\n  del(text) {\n    return `<del>${text}</del>`;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${title}\"`;\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  }\n\n  text(text) {\n    return text;\n  }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  html(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n}\n\n/**\n * Slugger generates header id\n */\nclass Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  /**\n   * @param {string} value\n   */\n  serialize(value) {\n    return value\n      .toLowerCase()\n      .trim()\n      // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '')\n      // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n  }\n\n  /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */\n  getNextSafeSlug(originalSlug, isDryRun) {\n    let slug = originalSlug;\n    let occurenceAccumulator = 0;\n    if (this.seen.hasOwnProperty(slug)) {\n      occurenceAccumulator = this.seen[originalSlug];\n      do {\n        occurenceAccumulator++;\n        slug = originalSlug + '-' + occurenceAccumulator;\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    if (!isDryRun) {\n      this.seen[originalSlug] = occurenceAccumulator;\n      this.seen[slug] = 0;\n    }\n    return slug;\n  }\n\n  /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */\n  slug(value, options = {}) {\n    const slug = this.serialize(value);\n    return this.getNextSafeSlug(slug, options.dryrun);\n  }\n}\n\n/**\n * Parsing & Compiling\n */\nclass Parser {\n  constructor(options) {\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.textRenderer = new TextRenderer();\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens, top = true) {\n    let out = '',\n      i,\n      j,\n      k,\n      l2,\n      l3,\n      row,\n      cell,\n      header,\n      body,\n      token,\n      ordered,\n      start,\n      loose,\n      itemBody,\n      item,\n      checked,\n      task,\n      checkbox,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'space': {\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr();\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(\n            this.parseInline(token.tokens),\n            token.depth,\n            unescape(this.parseInline(token.tokens, this.textRenderer)),\n            this.slugger);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token.text,\n            token.lang,\n            token.escaped);\n          continue;\n        }\n        case 'table': {\n          header = '';\n\n          // header\n          cell = '';\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            cell += this.renderer.tablecell(\n              this.parseInline(token.header[j].tokens),\n              { header: true, align: token.align[j] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n\n          body = '';\n          l2 = token.rows.length;\n          for (j = 0; j < l2; j++) {\n            row = token.rows[j];\n\n            cell = '';\n            l3 = row.length;\n            for (k = 0; k < l3; k++) {\n              cell += this.renderer.tablecell(\n                this.parseInline(row[k].tokens),\n                { header: false, align: token.align[k] }\n              );\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n          out += this.renderer.table(header, body);\n          continue;\n        }\n        case 'blockquote': {\n          body = this.parse(token.tokens);\n          out += this.renderer.blockquote(body);\n          continue;\n        }\n        case 'list': {\n          ordered = token.ordered;\n          start = token.start;\n          loose = token.loose;\n          l2 = token.items.length;\n\n          body = '';\n          for (j = 0; j < l2; j++) {\n            item = token.items[j];\n            checked = item.checked;\n            task = item.task;\n\n            itemBody = '';\n            if (item.task) {\n              checkbox = this.renderer.checkbox(checked);\n              if (loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                  }\n                } else {\n                  item.tokens.unshift({\n                    type: 'text',\n                    text: checkbox\n                  });\n                }\n              } else {\n                itemBody += checkbox;\n              }\n            }\n\n            itemBody += this.parse(item.tokens, loose);\n            body += this.renderer.listitem(itemBody, task, checked);\n          }\n\n          out += this.renderer.list(body, ordered, start);\n          continue;\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          out += this.renderer.html(token.text);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(this.parseInline(token.tokens));\n          continue;\n        }\n        case 'text': {\n          body = token.tokens ? this.parseInline(token.tokens) : token.text;\n          while (i + 1 < l && tokens[i + 1].type === 'text') {\n            token = tokens[++i];\n            body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n          }\n          out += top ? this.renderer.paragraph(body) : body;\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens, renderer) {\n    renderer = renderer || this.renderer;\n    let out = '',\n      i,\n      token,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token.text);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token.text);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token.href, token.title, token.text);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'em': {\n          out += renderer.em(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token.text);\n          break;\n        }\n        case 'br': {\n          out += renderer.br();\n          break;\n        }\n        case 'del': {\n          out += renderer.del(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token.text);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n}\n\nclass Hooks {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess'\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html) {\n    return html;\n  }\n}\n\nfunction onError(silent, async, callback) {\n  return (e) => {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n    if (silent) {\n      const msg = '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n      if (async) {\n        return Promise.resolve(msg);\n      }\n      if (callback) {\n        callback(null, msg);\n        return;\n      }\n      return msg;\n    }\n\n    if (async) {\n      return Promise.reject(e);\n    }\n    if (callback) {\n      callback(e);\n      return;\n    }\n    throw e;\n  };\n}\n\nfunction parseMarkdown(lexer, parser) {\n  return (src, opt, callback) => {\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    const origOpt = { ...opt };\n    opt = { ...marked.defaults, ...origOpt };\n    const throwError = onError(opt.silent, opt.async, callback);\n\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      return throwError(new Error('marked(): input parameter is undefined or null'));\n    }\n    if (typeof src !== 'string') {\n      return throwError(new Error('marked(): input parameter is of type '\n        + Object.prototype.toString.call(src) + ', string expected'));\n    }\n\n    checkSanitizeDeprecation(opt);\n\n    if (opt.hooks) {\n      opt.hooks.options = opt;\n    }\n\n    if (callback) {\n      const highlight = opt.highlight;\n      let tokens;\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src);\n        }\n        tokens = lexer(src, opt);\n      } catch (e) {\n        return throwError(e);\n      }\n\n      const done = function(err) {\n        let out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n            out = parser(tokens, opt);\n            if (opt.hooks) {\n              out = opt.hooks.postprocess(out);\n            }\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n\n        return err\n          ? throwError(err)\n          : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n\n      if (!tokens.length) return done();\n\n      let pending = 0;\n      marked.walkTokens(tokens, function(token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(() => {\n            highlight(token.text, token.lang, function(err, code) {\n              if (err) {\n                return done(err);\n              }\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    if (opt.async) {\n      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n        .then(src => lexer(src, opt))\n        .then(tokens => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n        .then(tokens => parser(tokens, opt))\n        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n        .catch(throwError);\n    }\n\n    try {\n      if (opt.hooks) {\n        src = opt.hooks.preprocess(src);\n      }\n      const tokens = lexer(src, opt);\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n      let html = parser(tokens, opt);\n      if (opt.hooks) {\n        html = opt.hooks.postprocess(html);\n      }\n      return html;\n    } catch (e) {\n      return throwError(e);\n    }\n  };\n}\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  marked.defaults = { ...marked.defaults, ...opt };\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args) {\n  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };\n\n  args.forEach((pack) => {\n    // copy options to new object\n    const opts = { ...pack };\n\n    // set async to true if it was set to true before\n    opts.async = marked.defaults.async || opts.async || false;\n\n    // ==-- Parse \"addon\" extensions --== //\n    if (pack.extensions) {\n      pack.extensions.forEach((ext) => {\n        if (!ext.name) {\n          throw new Error('extension name required');\n        }\n        if (ext.renderer) { // Renderer extensions\n          const prevRenderer = extensions.renderers[ext.name];\n          if (prevRenderer) {\n            // Replace extension with func to run new extension but fall back if false\n            extensions.renderers[ext.name] = function(...args) {\n              let ret = ext.renderer.apply(this, args);\n              if (ret === false) {\n                ret = prevRenderer.apply(this, args);\n              }\n              return ret;\n            };\n          } else {\n            extensions.renderers[ext.name] = ext.renderer;\n          }\n        }\n        if (ext.tokenizer) { // Tokenizer Extensions\n          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n            throw new Error(\"extension level must be 'block' or 'inline'\");\n          }\n          if (extensions[ext.level]) {\n            extensions[ext.level].unshift(ext.tokenizer);\n          } else {\n            extensions[ext.level] = [ext.tokenizer];\n          }\n          if (ext.start) { // Function to check for start of token\n            if (ext.level === 'block') {\n              if (extensions.startBlock) {\n                extensions.startBlock.push(ext.start);\n              } else {\n                extensions.startBlock = [ext.start];\n              }\n            } else if (ext.level === 'inline') {\n              if (extensions.startInline) {\n                extensions.startInline.push(ext.start);\n              } else {\n                extensions.startInline = [ext.start];\n              }\n            }\n          }\n        }\n        if (ext.childTokens) { // Child tokens to be visited by walkTokens\n          extensions.childTokens[ext.name] = ext.childTokens;\n        }\n      });\n      opts.extensions = extensions;\n    }\n\n    // ==-- Parse \"overwrite\" extensions --== //\n    if (pack.renderer) {\n      const renderer = marked.defaults.renderer || new Renderer();\n      for (const prop in pack.renderer) {\n        const prevRenderer = renderer[prop];\n        // Replace renderer with func to run extension, but fall back if false\n        renderer[prop] = (...args) => {\n          let ret = pack.renderer[prop].apply(renderer, args);\n          if (ret === false) {\n            ret = prevRenderer.apply(renderer, args);\n          }\n          return ret;\n        };\n      }\n      opts.renderer = renderer;\n    }\n    if (pack.tokenizer) {\n      const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n      for (const prop in pack.tokenizer) {\n        const prevTokenizer = tokenizer[prop];\n        // Replace tokenizer with func to run extension, but fall back if false\n        tokenizer[prop] = (...args) => {\n          let ret = pack.tokenizer[prop].apply(tokenizer, args);\n          if (ret === false) {\n            ret = prevTokenizer.apply(tokenizer, args);\n          }\n          return ret;\n        };\n      }\n      opts.tokenizer = tokenizer;\n    }\n\n    // ==-- Parse Hooks extensions --== //\n    if (pack.hooks) {\n      const hooks = marked.defaults.hooks || new Hooks();\n      for (const prop in pack.hooks) {\n        const prevHook = hooks[prop];\n        if (Hooks.passThroughHooks.has(prop)) {\n          hooks[prop] = (arg) => {\n            if (marked.defaults.async) {\n              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then(ret => {\n                return prevHook.call(hooks, ret);\n              });\n            }\n\n            const ret = pack.hooks[prop].call(hooks, arg);\n            return prevHook.call(hooks, ret);\n          };\n        } else {\n          hooks[prop] = (...args) => {\n            let ret = pack.hooks[prop].apply(hooks, args);\n            if (ret === false) {\n              ret = prevHook.apply(hooks, args);\n            }\n            return ret;\n          };\n        }\n      }\n      opts.hooks = hooks;\n    }\n\n    // ==-- Parse WalkTokens extensions --== //\n    if (pack.walkTokens) {\n      const walkTokens = marked.defaults.walkTokens;\n      opts.walkTokens = function(token) {\n        let values = [];\n        values.push(pack.walkTokens.call(this, token));\n        if (walkTokens) {\n          values = values.concat(walkTokens.call(this, token));\n        }\n        return values;\n      };\n    }\n\n    marked.setOptions(opts);\n  });\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens, callback) {\n  let values = [];\n  for (const token of tokens) {\n    values = values.concat(callback.call(marked, token));\n    switch (token.type) {\n      case 'table': {\n        for (const cell of token.header) {\n          values = values.concat(marked.walkTokens(cell.tokens, callback));\n        }\n        for (const row of token.rows) {\n          for (const cell of row) {\n            values = values.concat(marked.walkTokens(cell.tokens, callback));\n          }\n        }\n        break;\n      }\n      case 'list': {\n        values = values.concat(marked.walkTokens(token.items, callback));\n        break;\n      }\n      default: {\n        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) { // Walk any extensions\n          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {\n            values = values.concat(marked.walkTokens(token[childTokens], callback));\n          });\n        } else if (token.tokens) {\n          values = values.concat(marked.walkTokens(token.tokens, callback));\n        }\n      }\n    }\n  }\n  return values;\n};\n\n/**\n * Parse Inline\n * @param {string} src\n */\nmarked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);\n\n/**\n * Expose\n */\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.Hooks = Hooks;\nmarked.parse = marked;\n\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = Parser.parse;\nconst lexer = Lexer.lex;\n\nexport { Hooks, Lexer, Parser, Renderer, Slugger, TextRenderer, Tokenizer, defaults, getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };\n","import { createElement, Fragment } from 'react';\nimport { Lexer } from 'marked';\n\nconst htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n};\n/** Used to match HTML entities and HTML characters. */\nconst reEscapedHtml = /&(?:amp|lt|gt|quot|#(?:0+)?39);/g;\nconst reHasEscapedHtml = RegExp(reEscapedHtml.source);\nconst unescape = (str = '') => {\n    return reHasEscapedHtml.test(str) ? str.replace(reEscapedHtml, (entity) => htmlUnescapes[entity] || \"'\") : str;\n};\nconst joinBase = (path, base) => {\n    if (!base) {\n        return path;\n    }\n    try {\n        return new URL(path, base).href;\n    }\n    catch (_a) {\n        return path;\n    }\n};\n\nclass ReactParser {\n    constructor(options) {\n        this.renderer = options.renderer;\n    }\n    parse(tokens) {\n        return tokens.map((token) => {\n            switch (token.type) {\n                case 'space': {\n                    return null;\n                }\n                case 'heading': {\n                    const level = token.depth;\n                    return this.renderer.heading(this.parseInline(token.tokens), level);\n                }\n                case 'paragraph': {\n                    return this.renderer.paragraph(this.parseInline(token.tokens));\n                }\n                case 'text': {\n                    const textTokens = token.tokens;\n                    return textTokens ? this.parseInline(textTokens) : token.text;\n                }\n                case 'blockquote': {\n                    const quote = this.parse(token.tokens);\n                    return this.renderer.blockquote(quote);\n                }\n                case 'list': {\n                    const children = token.items.map((item) => {\n                        var _a;\n                        const listItemChildren = [];\n                        if (item.task) {\n                            listItemChildren.push(this.renderer.checkbox((_a = item.checked) !== null && _a !== void 0 ? _a : false));\n                        }\n                        listItemChildren.push(this.parse(item.tokens));\n                        return this.renderer.listItem(listItemChildren);\n                    });\n                    return this.renderer.list(children, token.ordered);\n                }\n                case 'code': {\n                    return this.renderer.code(token.text, token.lang);\n                }\n                case 'html': {\n                    return this.renderer.html(token.text);\n                }\n                case 'table': {\n                    const headerCells = token.header.map((cell, index) => {\n                        return this.renderer.tableCell(this.parseInline(cell.tokens), { header: true, align: token.align[index] });\n                    });\n                    const headerRow = this.renderer.tableRow(headerCells);\n                    const header = this.renderer.tableHeader(headerRow);\n                    const bodyChilren = token.rows.map((row) => {\n                        const rowChildren = row.map((cell, index) => {\n                            return this.renderer.tableCell(this.parseInline(cell.tokens), {\n                                header: false,\n                                align: token.align[index],\n                            });\n                        });\n                        return this.renderer.tableRow(rowChildren);\n                    });\n                    const body = this.renderer.tableBody(bodyChilren);\n                    return this.renderer.table([header, body]);\n                }\n                case 'hr': {\n                    return this.renderer.hr();\n                }\n                default: {\n                    console.warn(`Token with \"${token.type}\" type was not found`); // eslint-disable-line no-console\n                    return null;\n                }\n            }\n        });\n    }\n    parseInline(tokens) {\n        return tokens.map((token) => {\n            switch (token.type) {\n                case 'text': {\n                    return this.renderer.text(unescape(token.text));\n                }\n                case 'strong': {\n                    return this.renderer.strong(this.parseInline(token.tokens));\n                }\n                case 'em': {\n                    return this.renderer.em(this.parseInline(token.tokens));\n                }\n                case 'del': {\n                    return this.renderer.del(this.parseInline(token.tokens));\n                }\n                case 'codespan': {\n                    return this.renderer.codespan(unescape(token.text));\n                }\n                case 'link': {\n                    return this.renderer.link(token.href, this.parseInline(token.tokens));\n                }\n                case 'image': {\n                    return this.renderer.image(token.href, token.text, token.title);\n                }\n                case 'html': {\n                    return this.renderer.html(token.text);\n                }\n                case 'br': {\n                    return this.renderer.br();\n                }\n                case 'escape': {\n                    return this.renderer.text(token.text);\n                }\n                default: {\n                    console.warn(`Token with \"${token.type}\" type was not found`); // eslint-disable-line no-console\n                    return null;\n                }\n            }\n        });\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar _ReactRenderer_instances, _ReactRenderer_elId, _ReactRenderer_options, _ReactRenderer_h, _ReactRenderer_incrementElId;\nclass ReactRenderer {\n    constructor(options = {}) {\n        _ReactRenderer_instances.add(this);\n        _ReactRenderer_elId.set(this, 0);\n        _ReactRenderer_options.set(this, void 0);\n        const { renderer } = options;\n        __classPrivateFieldSet(this, _ReactRenderer_options, options, \"f\");\n        if (renderer && typeof renderer === 'object') {\n            Object.entries(renderer).forEach(([key, value]) => {\n                const rendererName = key;\n                const rendererFunction = value;\n                if (!this[rendererName] || rendererName === 'elementId' || typeof rendererFunction !== 'function') {\n                    return;\n                }\n                this[rendererName];\n                this[rendererName] = (...args) => {\n                    __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_incrementElId).call(this);\n                    return rendererFunction.apply(this, args);\n                };\n            });\n        }\n    }\n    get elementId() {\n        return __classPrivateFieldGet(this, _ReactRenderer_elId, \"f\");\n    }\n    heading(children, level) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, `h${level}`, children);\n    }\n    paragraph(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'p', children);\n    }\n    link(href, text) {\n        const url = joinBase(href, __classPrivateFieldGet(this, _ReactRenderer_options, \"f\").baseURL);\n        const target = __classPrivateFieldGet(this, _ReactRenderer_options, \"f\").openLinksInNewTab ? '_blank' : null;\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'a', text, { href: url, target });\n    }\n    image(src, alt, title) {\n        const url = joinBase(src, __classPrivateFieldGet(this, _ReactRenderer_options, \"f\").baseURL);\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'img', null, { src: url, alt, title });\n    }\n    codespan(code, lang = null) {\n        const className = lang ? `${__classPrivateFieldGet(this, _ReactRenderer_options, \"f\").langPrefix}${lang}` : null;\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'code', code, { className });\n    }\n    code(code, lang) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'pre', this.codespan(code, lang));\n    }\n    blockquote(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'blockquote', children);\n    }\n    list(children, ordered) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, ordered ? 'ol' : 'ul', children);\n    }\n    listItem(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'li', children);\n    }\n    checkbox(checked) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'input', null, { type: 'checkbox', disabled: true, checked });\n    }\n    table(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'table', children);\n    }\n    tableHeader(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'thead', children);\n    }\n    tableBody(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'tbody', children);\n    }\n    tableRow(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'tr', children);\n    }\n    tableCell(children, flags) {\n        const tag = flags.header ? 'th' : 'td';\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, tag, children, { align: flags.align });\n    }\n    strong(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'strong', children);\n    }\n    em(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'em', children);\n    }\n    del(children) {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'del', children);\n    }\n    text(text) {\n        return text;\n    }\n    html(html) {\n        return html;\n    }\n    hr() {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'hr');\n    }\n    br() {\n        return __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_h).call(this, 'br');\n    }\n}\n_ReactRenderer_elId = new WeakMap(), _ReactRenderer_options = new WeakMap(), _ReactRenderer_instances = new WeakSet(), _ReactRenderer_h = function _ReactRenderer_h(el, children = null, props = {}) {\n    const elProps = {\n        key: `marked-react-${this.elementId}`,\n    };\n    __classPrivateFieldGet(this, _ReactRenderer_instances, \"m\", _ReactRenderer_incrementElId).call(this);\n    return createElement(el, Object.assign(Object.assign({}, props), elProps), children);\n}, _ReactRenderer_incrementElId = function _ReactRenderer_incrementElId() {\n    __classPrivateFieldSet(this, _ReactRenderer_elId, __classPrivateFieldGet(this, _ReactRenderer_elId, \"f\") + 1, \"f\");\n};\n\nconst validateComponentProps = (props) => {\n    if (props.value && typeof props.value !== 'string') {\n        throw new TypeError(`[marked-react]: Expected value to be of type string but got ${typeof props.value}`);\n    }\n    if (props.children && typeof props.children !== 'string') {\n        throw new TypeError(`[marked-react]: Expected children to be of type string but got ${typeof props.children}`);\n    }\n};\nconst defaultProps = {\n    isInline: false,\n    breaks: false,\n    gfm: true,\n    baseURL: undefined,\n    openLinksInNewTab: true,\n    langPrefix: 'language-',\n    renderer: undefined,\n};\nconst Markdown = (incomingProps) => {\n    var _a, _b;\n    const props = Object.assign(Object.assign({}, defaultProps), incomingProps);\n    validateComponentProps(props);\n    // lexer options\n    const lexerOptions = {\n        breaks: props.breaks,\n        gfm: props.gfm,\n    };\n    // convert input markdown into tokens\n    const markdownString = (_b = (_a = props.value) !== null && _a !== void 0 ? _a : props.children) !== null && _b !== void 0 ? _b : '';\n    const tokens = props.isInline\n        ? Lexer.lexInline(markdownString, lexerOptions)\n        : Lexer.lex(markdownString, lexerOptions);\n    // parser options\n    const parserOptions = {\n        renderer: new ReactRenderer({\n            renderer: props.renderer,\n            baseURL: props.baseURL,\n            openLinksInNewTab: props.openLinksInNewTab,\n            langPrefix: props.langPrefix,\n        }),\n    };\n    const parser = new ReactParser(parserOptions);\n    const children = props.isInline ? parser.parseInline(tokens) : parser.parse(tokens);\n    return createElement(Fragment, null, children);\n};\n\nexport { ReactParser, ReactRenderer, Markdown as default };\n","import React, { useState } from \"react\";\nimport useSWR from \"swr\";\nimport { fetcher } from \"../../../api/http\";\nimport addMessage from \"../../../api/account/tickets/addMessage\";\nimport { toast } from \"react-toastify\";\nimport Loading from \"../../Elements/Loading\";\nimport moment from \"moment/moment\";\nimport Markdown from \"marked-react\";\nimport { Account } from \"../Manager/Forms/EditAccountForm\";\nimport { bool } from \"yup\";\n\nexport interface Message {\n  message: string;\n  first_name: string;\n  last_name: string;\n  created_at: string;\n  discord_user_id: number;\n  own: boolean;\n  role: boolean\n}\n\ninterface MessagesData {\n  page: number;\n  totalPage: number;\n  perPage: number;\n  messages: Message[];\n\n}\nexport interface MessagesRequest {\n  status: string;\n  message?: string;\n  data?: MessagesData\n}\n\n  export default function ConversationRow({id,account,page, open}: {id: string, account: Account, page: number, open: boolean}) {\n  const [loading, setLoading] = useState(false);\n  const [message, setMessage] = useState<string>('');\n  const {data, error, isLoading, mutate } = useSWR<MessagesRequest>(\n    `https://privateapi.bagou450.com/api/client/web/tickets/${id}/messages?page=${page}&perPage=10`,\n    fetcher\n  );\n  if (!data || (error || isLoading)) {\n    return <Loading/>;\n  }\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setMessage(e.target.value)\n  };\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if(!id) {\n      return;\n    }\n    console.log(message);\n    addMessage(id, message, account, []).then((data) => {\n      data = data.data;\n      setLoading(false);\n      mutate();\n\n      if(data['status'] === 'success') {\n\n        return toast.success(`Your message had been sent`, {\n          position: \"bottom-right\",\n          autoClose: 5000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true,\n          progress: undefined,\n          theme: \"dark\",\n        });\n      }\n      toast.error(`Error: ${data['message']}`, {\n        position: \"bottom-right\",\n        autoClose: 5000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: \"dark\",\n      });\n    }).catch((e) => {\n      toast.error(`Error: ${e}`, {\n        position: \"bottom-right\",\n        autoClose: 5000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: \"dark\",\n      });\n      setLoading(false);\n    });\n  };\n\n  if(!data.data) {\n    return <Loading/>;\n  }\n  return (\n    <div>\n      {data.data.messages.map((message: Message, index: number) => {\n        return (\n\n          <div key={index} className={message.own ? \"chat chat-end\" : \"chat chat-start\"}>\n            <div className=\"chat-image avatar\">\n              <div className=\"w-10 rounded-full\">\n                <img src={`https://ui-avatars.com/api/?background=042049&color=5271ff&name=${message.first_name[0]}${message.last_name[0]}`} />\n              </div>\n            </div>\n            <div className=\"chat-header\">\n              {message.role ? <div className=\"badge badge-primary mx-1 badge-sm\">Support</div> : <></>} {message.first_name} {message.last_name}\n              <time className=\"text-xs opacity-50 mx-1\">{moment(message.created_at).fromNow()}</time>\n            </div>\n            <div className=\"chat-bubble break-words\"><Markdown breaks={true} openLinksInNewTab={true}>{message.message.replaceAll(/\\n\\n/g, '\\n \\n')}</Markdown></div>\n          </div>\n\n        );\n      })}\n      {data.data.totalPage === page && open &&\n        <div className={'mt-4 mx-4'}>\n\n          <form onSubmit={handleSubmit}>\n\n            <textarea placeholder=\"New message\" className={loading ? \"textarea textarea-bordered textarea-lg w-full\" : \"textarea textarea-bordered textarea-lg w-full disabled\"} name={'message'} disabled={loading} onChange={handleChange}></textarea>\n            <button className=\"mt-2 outline-0 float-right btn btn-outline btn-primary\" type={'submit'} disabled={loading}>Send message</button>\n          </form>\n        </div>\n      }\n\n    </div>\n  )\n}","import { config } from \"../../../config/config\";\nimport http from \"../../http\";\n\n\nconst createTicket = (ticket:string, status: string): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    http\n      .post(`${config.privateapilink}/tickets/${ticket}/status`, { status })\n      .then((data) => resolve(data))\n      .catch(reject);\n  });\n};\n\nexport default createTicket;","import React, { useEffect, useState } from \"react\";\nimport { useNavigate, useParams } from \"react-router-dom\";\nimport useSWR from \"swr\";\nimport 'react-toastify/dist/ReactToastify.min.css';\nimport { fetcher } from '../../../api/http';\nimport NavBarAccount from '../NavBarAccount';\nimport Loading from \"../../Elements/Loading\";\nimport { Account } from \"../Manager/Forms/EditAccountForm\";\nimport moment from 'moment';\nimport { toast } from \"react-toastify\";\nimport { FaDownload } from \"react-icons/fa\";\nimport { config } from \"../../../config/config\";\nimport Cookies from \"js-cookie\";\nimport Markdown from 'marked-react';\nimport breaks from 'remark-breaks';\nimport addMessage from \"../../../api/account/tickets/addMessage\";\nimport ConversationRow, { MessagesRequest } from \"./ConversationRow\";\nimport updateTicket from \"../../../api/account/tickets/updateTicket\";\n\n\ninterface Attachment {\n  id: number;\n  name: string;\n  size: number;\n}\nconst formatSize = (sizeInBytes: number) => {\n  const units = [\"b\", \"Kb\", \"Mb\", \"Gb\", \"Tb\"];\n  let size = sizeInBytes;\n  let unitIndex = 0;\n\n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n\n  return `${size.toFixed(2)} ${units[unitIndex]}`;\n};\nexport default function TicketViewContainer() {\n  const { id } = useParams();\n  const [page, setPage] = useState<number>(1);\n  const [loading, setLoading] = useState<boolean>(false);\n\n  useEffect(() => {\n    window.scrollTo(0,0);\n  }, [])\n  const { data,  error: error, isLoading, mutate } = useSWR(\n    `${config.privateapilink}/tickets/${id}/details`,\n    fetcher\n  );\n  const { data: data2, error: error2, isLoading: isLoading2 } = useSWR(\n    `${config.privateapilink}/auth/isLogged?infos=true`,\n    fetcher\n  );\n  const { data: data3, error: error3, isLoading: isLoading3 } = useSWR<MessagesRequest>(\n    `${config.privateapilink}/tickets/${id}/messages?page=${page}&perPage=10`,\n    fetcher\n  );\n\n  const navigation = useNavigate();\n  if ((!data || (error || isLoading)) || (!data2 || (error2 || isLoading2)) || (!data3 || (error3 || isLoading3))) {\n    return <Loading/>;\n  }\n  const account: Account = data2.data;\n  const totalPage = data3.data!.totalPage;\n  const UpdateStatus = () => {\n    setLoading(true);\n    updateTicket(data.data.ticket.id, data.data.ticket.status !== 'closed' ? 'closed' : account.role ? 'support_answer' : 'client_answer').then((data) => {\n      console.log(data)\n      if(data.data.status === 'error') {\n        toast.error(`Error: ${data.data.message}`, {\n          position: \"bottom-right\",\n          autoClose: 5000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true,\n          progress: undefined,\n          theme: \"dark\",\n        });\n        setLoading(false);\n        return;\n      }\n      window.scrollTo(0,0);\n      mutate();\n      toast.success(`Ticket status modified successfully.`, {\n        position: \"bottom-right\",\n        autoClose: 5000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: \"dark\",\n      });\n      setLoading(false);\n    }).catch((e) => {\n      toast.error(`Error: ${e}`, {\n        position: \"bottom-right\",\n        autoClose: 5000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: \"dark\",\n      });\n      setLoading(false);\n    })\n\n  }\n  document.title = `Bagou450 -  Ticket ${id}`\n  return (\n    <>\n      <NavBarAccount tab={'tickets'}/>\n      <section className='mx-8 my-4 grid grid-cols-1 md:grid-cols-4'>\n\n        <div>\n        <InfoBlock data={data}/>\n        <AttachmentsBlock data={data}/>\n          <div>\n            {page > 1 &&\n              <button className='btn btn-outline btn-secondary mt-2 outline-0' onClick={() => {setPage(page-1); window.scrollTo(0,0);}}>Previous page</button>\n            }\n            {page < totalPage &&\n              <button className='btn btn-outline btn-secondary mt-2 outline-0 float-right' onClick={() => {setPage(page+1); window.scrollTo(0,0);}}>Next page</button>\n            }\n          </div>\n          <button disabled={loading} className={data.data.ticket.status === 'closed' ? 'btn-success btn btn-outline mt-2 outline-0' : 'btn-error btn btn-outline mt-2 outline-0'} onClick={() => UpdateStatus()}>{data.data.ticket.status === 'closed' ? 'Open Ticket' : 'Close ticket'}</button>\n\n\n        </div>\n        <div className={'mx-4 col-span-3'}>\n          <ConversationRow open={data.data.ticket.status !== 'closed'} id={data.data.ticket.id} account={account} page={page}/>\n\n        </div>\n\n      </section>\n      <section className='min-h-screen'></section>\n    </>\n  );\n}\n\n\nfunction InfoBlock({data}: {data: any}) {\n  return (\n    <div className={'bg-neutral rounded-md'}>\n      <h2 className={'text-center text-xl font-bold mt-1 pt-4'} title={data.data.ticket.name}>{data.data.ticket.name[0].toUpperCase()}{(data.data.ticket.name.length > 36 ? data.data.ticket.name.slice(1, 33) + '...' : data.data.ticket.name.slice(1, data.data.ticket.name.length))}</h2>\n      <div className=\"divider\"></div>\n      <ul className={'ml-5 list-disc'}>\n        <li className={'mt-2'}><span className={'font-semibold'}>Status:</span> <span className={data.data.ticket.status === 'closed' ? ' text-red-700' : (data.data.ticket.status === 'support_answer' ? ' text-green-700' : ' text-blue-700')}>{data.data.ticket.status === 'client_answer' ? 'Answered by Client' : data.data.ticket.status === 'support_answer' ? 'Answered by Support' : 'Closed'}</span></li>\n        <li className={'mt-2'}><span className={'font-semibold'}>Priority:</span> <span className={data.data.ticket.priority === 'high' ? 'text-red-700' : data.data.ticket.priority === 'low' ? 'text-green-700' : ''}>{data.data.ticket.priority[0].toUpperCase()}{data.data.ticket.priority.slice(1, data.data.ticket.priority.length)}</span></li>\n        <li className={'mt-2'}><span className={'font-semibold'}>Logs Url:</span> {data.data.ticket.logs_url && data.data.ticket.logs_url !== '' ? data.data.ticket.logs_url : 'No logs provided'}</li>\n        <li className={'mt-2 cursor-copy'} title={data.data.ticket.license} onClick={() => {\n          navigator.clipboard.writeText(data.data.ticket.license)\n          toast.success(`Copied to clipboard!.`, {\n            position: \"bottom-right\",\n            autoClose: 1500,\n            hideProgressBar: false,\n            closeOnClick: true,\n            pauseOnHover: true,\n            draggable: true,\n            progress: undefined,\n            theme: \"dark\",\n          });\n        }}><span className={'font-semibold'}>License/Order:</span> {data.data.ticket.license && data.data.ticket.license !== '' ? (data.data.ticket.license.length > 30 ? data.data.ticket.license.slice(0,31) + '...' : data.data.ticket.license)  : 'No license or order provided'}</li>\n        <li className={'mt-2'}><span className={'font-semibold'}>Creation:</span> {new Date(data.data.ticket.created_at).toLocaleDateString(\"fr-FR\")}</li>\n        <li className={'mt-2 pb-2'}><span className={'font-semibold'}>Last update:</span> {moment(data.data.ticket.updated_at).fromNow()}</li>\n      </ul>\n    </div>\n  )\n}\nfunction AttachmentsBlock({data}: {data: any}) {\n  const [loading, setLoading] = useState(false);\n  const downloadAttachmentFunction = (id: number, name: string) => {\n    setLoading(true);\n    fetch(`${config.privateapilink}/tickets/${id}/download`, {headers: {\n        'X-Requested-With': 'XMLHttpRequest',\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${Cookies.get('access_token')}`\n      }}).then(response => response.blob()).then(blob => {\n\n      const url = window.URL.createObjectURL(new Blob([blob]));\n      const link = document.createElement('a');\n      link.href = url;\n      link.setAttribute('download', `name`);\n      document.body.appendChild(link);\n      link.addEventListener('load', () => {\n        URL.revokeObjectURL(url);\n      });\n      link.click();\n      if (link.parentNode) {\n        link.parentNode.removeChild(link);\n      }\n      toast.success('Your file is now downloaded!', {\n        position: \"bottom-right\",\n        autoClose: 5000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: \"dark\",\n      });\n      setLoading(false);\n    }).catch((e) => {\n      toast.error(`Error: ${e}`, {\n        position: \"bottom-right\",\n        autoClose: 5000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: \"dark\",\n      });\n      setLoading(false);\n    });\n  }\n  return (\n    <div className={'bg-neutral rounded-md mt-2'}>\n      <h2 className={'text-center text-xl font-bold pt-4'}>Attachments</h2>\n      <div className=\"divider\"></div>\n      {data.data.attachments.length < 1 ?\n        <p className={'text-center pb-2'}>No attachments found.</p>\n        :\n        <ul className={'ml-5 mb-4 list-disc'}>\n          {data.data.attachments.map((attachment: Attachment, index: number) => {\n            return <li key={index} className={'pb-2 cursor-pointer'} onClick={() => {if(!loading) {downloadAttachmentFunction(attachment.id, attachment.name)}}}><p className={'flex'}><span className={'font-semibold'}>{attachment.name}</span>, {formatSize(attachment.size)} <FaDownload className={'ml-2 mt-1'}/></p></li>;\n\n          })}\n        </ul>\n      }\n\n    </div>\n  )\n}\n\n\n"],"names":["Link","useLocation","React","useState","fetcher","useSWR","Loading","config","NavBarAccount","tab","location","admin","showAdmin","pathname","startsWith","data","error","isLoading","privateapilink","createElement","Fragment","className","name","toUpperCase","slice","length","to","xmlns","fill","viewBox","stroke","strokeLinecap","strokeLinejoin","strokeWidth","d","role","type","checked","onClick","http","addMessage","id","message","account","attachments","formData","FormData","append","forEach","file","discord","Promise","resolve","reject","post","then","catch","toast","moment","Markdown","ConversationRow","_ref","page","open","loading","setLoading","setMessage","mutate","handleChange","e","target","value","handleSubmit","preventDefault","console","log","success","position","autoClose","hideProgressBar","closeOnClick","pauseOnHover","draggable","progress","undefined","theme","messages","map","index","key","own","src","first_name","last_name","created_at","fromNow","breaks","openLinksInNewTab","replaceAll","totalPage","onSubmit","placeholder","disabled","onChange","createTicket","ticket","status","useEffect","useNavigate","useParams","FaDownload","Cookies","updateTicket","formatSize","sizeInBytes","units","size","unitIndex","toFixed","TicketViewContainer","setPage","window","scrollTo","data2","error2","isLoading2","data3","error3","isLoading3","navigation","UpdateStatus","document","title","InfoBlock","AttachmentsBlock","priority","logs_url","license","navigator","clipboard","writeText","Date","toLocaleDateString","updated_at","_ref2","downloadAttachmentFunction","fetch","headers","Accept","Authorization","get","response","blob","url","URL","createObjectURL","Blob","link","href","setAttribute","body","appendChild","addEventListener","revokeObjectURL","click","parentNode","removeChild","attachment"],"sourceRoot":""}